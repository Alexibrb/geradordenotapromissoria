/**
 * @file Firebase Security Rules for Promissory Note App
 * @description This ruleset enforces a strict user-ownership model, ensuring that users can only access their own data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. The document ID must match the user's auth UID.
 * - /users/{userId}/clients/{clientId}: Stores client information for a specific user.
 * - /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId}: Stores promissory notes for a specific client.
 * - /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId}/payments/{paymentId}: Stores payment information for a specific promissory note.
 * - /users/{userId}/settings/appSettings: Stores user-specific settings.
 * - /app_settings/general: Stores global application settings (single document).
 *
 * Key Security Decisions:
 * - Strict user-ownership: Users can only read and write data under their own user ID.
 * - User listing is disallowed.
 * - Global settings are publicly readable but only writable under specific authorization.
 *
 * Denormalization for Authorization:
 * - The rules rely on path-based authorization, where the `userId` in the path is compared against `request.auth.uid`. This avoids the need for complex `get()` calls or separate role collections.
 *
 * Structural Segregation:
 * - User-specific data is stored under the `/users/{userId}` path, ensuring privacy and isolation.
 * - Global settings are stored in the `/app_settings/general` path, making them accessible under the defined conditions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profiles.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' can create their profile at /users/user123.
     * @allow (get, update, delete) - User with UID 'user123' can get, update, and delete their profile at /users/user123.
     * @deny (create) - User with UID 'user456' cannot create a profile at /users/user123.
     * @deny (update, delete) - User with UID 'user456' cannot update or delete the profile at /users/user123.
     * @principle Enforces document ownership: only the user with the matching UID can create, read, update, or delete their profile.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for clients.
     * @path /users/{userId}/clients/{clientId}
     * @allow (create) - User with UID 'user123' can create a client under their user ID.
     * @allow (get, list, update, delete) - User with UID 'user123' can access their own clients.
     * @deny (create) - User with UID 'user456' cannot create a client under user123's ID.
     * @deny (update, delete) - User with UID 'user456' cannot update or delete clients under user123's ID.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, and validates relational integrity.
     */
    match /users/{userId}/clients/{clientId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for promissory notes.
     * @path /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId}
     * @allow (create) - User with UID 'user123' can create a promissory note under their client and user ID.
     * @allow (get, list, update, delete) - User with UID 'user123' can access their own promissory notes.
     * @deny (create) - User with UID 'user456' cannot create a promissory note under user123's client.
     * @deny (update, delete) - User with UID 'user456' cannot update or delete promissory notes under user123's client.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, and validates relational integrity.
     */
    match /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for payments.
     * @path /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId}/payments/{paymentId}
     * @allow (create) - User with UID 'user123' can create a payment under their promissory note.
     * @allow (get, list, update, delete) - User with UID 'user123' can access their own payments.
     * @deny (create) - User with UID 'user456' cannot create a payment under user123's promissory note.
     * @deny (update, delete) - User with UID 'user456' cannot update or delete payments under user123's promissory note.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, and validates relational integrity.
     */
    match /users/{userId}/clients/{clientId}/promissoryNotes/{promissoryNoteId}/payments/{paymentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user settings.
     * @path /users/{userId}/settings/appSettings
     * @allow (get, update) - User with UID 'user123' can get and update their own settings.
     * @deny (create) - User with UID 'user456' cannot create settings for user123.
     * @deny (update, delete) - User with UID 'user456' cannot update or delete settings for user123.
     * @principle Enforces document ownership for writes and restricts access to a user's own settings.
     */
    match /users/{userId}/settings/appSettings {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if false; // Only one document, created implicitly.
      allow update: if isExistingOwner(userId);
      allow delete: if false; // Deletion not allowed.
    }

    /**
     * @description Allows read access to global application settings for all users, but restricts write access.
     * @path /app_settings/general
     * @allow (get, list) - Any user can read the global application settings.
     * @deny (create, update, delete) - Only authenticated users with specific roles can modify the settings.
     * @principle Allows public read access while restricting write access to authorized users.
     */
    match /app_settings/general {
        // TODO: implement roles to edit app_settings/general
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once the schema is updated with an ownership field.
    }
  }
}